<!DOCTYPE html>
<!-- Tutorial from threejs.org 
Note to self - python server command is
python -m http.server
-->
<html>
	<head>
		<meta charset=utf-8>
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>

		<script src="js/shaders/CopyShader.js"></script>
		<script src="js/shaders/DotScreenShader.js"></script>
		<script src="js/shaders/RGBShiftShader.js"></script>

		<script src="js/postprocessing/EffectComposer.js"></script>
		<script src="js/postprocessing/RenderPass.js"></script>
		<script src="js/postprocessing/MaskPass.js"></script>
		<script src="js/postprocessing/ShaderPass.js"></script>

		<script>
var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 1000 );
camera.position.set(0, 5, 15);
camera.lookAt(new THREE.Vector3(0, 0, 0));



var renderer = new THREE.WebGLRenderer();
renderer.setSize( window.innerWidth*2, window.innerHeight*2,false); //foce 2x2 multi-sample to reduce aliasing
document.body.appendChild( renderer.domElement );

var geometry = new THREE.BoxGeometry( 2, 2, 2 );
var material = new THREE.MeshPhongMaterial( { color: 0x00ff00 } );
var cube = new THREE.Mesh( geometry, material );
scene.add( cube );

//now, add a line
material = new THREE.LineBasicMaterial({ color: 0x1010ff });
geometry = new THREE.Geometry();
geometry.vertices.push(new THREE.Vector3(-5, 0, 0));
geometry.vertices.push(new THREE.Vector3(0, 5, 0));
geometry.vertices.push(new THREE.Vector3(5, 0, 0));
var line = new THREE.Line(geometry, material);
scene.add(line);

var light1 = new THREE.PointLight({color: 0xFFFF00}, 1.0, 500, 2);
light1.position.set(10,10,10);
scene.add(light1);

var light2 = new THREE.AmbientLight({color: 0xA0A0FF}, 0.01);
scene.add(light2);


// postprocessing
//define shader

MyShader = {

	uniforms: {
		"tDiffuse": { type: "t", value: null },
		//"amount":     { type: "f", value: 0.5 }
	},

	vertexShader: [

	"varying vec2 vUv;",
	"void main() {",
		"vUv = uv;",
		"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

	"}"

	].join("\n"),

	fragmentShader:`
uniform sampler2D tDiffuse; //input texture
varying vec2 vUv;

void main() {
vec2 p = vUv;
//if (p.x > 0.5) p.x = 1.0 - p.x;
vec4 color = texture2D(tDiffuse, p);

//let's make that gamma correct
color = pow(color, vec4(1.0/2.2));

gl_FragColor = color;
}`

};



//apply shader
composer = new THREE.EffectComposer( renderer );
composer.addPass( new THREE.RenderPass( scene, camera ) );

var seffect = new THREE.ShaderPass( MyShader );
seffect.renderToScreen = true;
composer.addPass( seffect );



function render() {
	requestAnimationFrame( render );
	composer.render( scene, camera );
	cube.rotation.x += 0.001;
    cube.rotation.y += 0.002;
}
render();

		</script>
	</body>
</html>